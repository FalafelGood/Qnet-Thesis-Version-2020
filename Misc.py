from QNET import *
import string

def cv_strip_add(cost_vector):
    """
    Strips the additive costs from a cost vector, leaving only the metric costs.

    Parameters
    ----------
    cost_vector: dict

    Returns
    -------
    dict
    """
    kill_list = []
    for key in cost_vector:
        if key.startswith("add_"):
            kill_list.append(key)
    for snitch in kill_list:
        cost_vector.pop(snitch)
    return cost_vector


def get_diagonal_pair_method(dim, size, G):
    """
    This is a function that returns a function for fetching the off-diagonal pairs of an arbitrarily sized graph
    generated by multidim_lattice

    Parameters
    ----------
    dim: int
        Dimension of the graph
    size: int
        Size of the graph
    G: Qnet()
        Multidim lattice graph

    Returns
    -------
    function

    """
    head_string = "("
    tail_string = "("

    i = 0
    while i < dim:
        head_string += "0"
        tail_string += str(size - 1)
        i += 1
        if i < dim:
            head_string += ", "
            tail_string += ", "
    head_string += ")"
    tail_string += ")"

    def diagonal_pair(G):
        """Function to return"""
        head = G.getNode(head_string)
        tail = G.getNode(tail_string)
        return head, tail
    return diagonal_pair


def fixed_pair(square):
    """
    Get the nodes that are a fixed off-diagonal distance from each other in a given graph, as close to the middle as
    possible

    Parameters
    ----------
    square: Square lattice graph

    Returns
    -------
    (Qnode, Qnode)
    """
    # Diagonal distance required. Diagonal distance is measured in number of diagonal steps. Hence an n x n graph has
    # A max diag of 5
    diag = 7
    square_width = int(np.sqrt(number_of_nodes(square)))
    # nodes separated by a diagonal of length "diag" lie on a square of size diag + 1.
    small_square_width = diag + 1
    # Check if graph is large enough for given diag.
    assert(square_width >= small_square_width)

    # Center small_square
    lower_coord = (square_width - small_square_width) // 2
    upper_coord = lower_coord + small_square_width -1

    u_str = "(" + str(lower_coord) + ", " + str(lower_coord) + ")"
    v_str = "(" + str(upper_coord) + ", " + str(upper_coord) + ")"

    u = square.getNode(u_str)
    v = square.getNode(v_str)

    return u, v


def random_pair_variable_lattice():
    def random_pair(G):
        """Get a random pair of nodes from graph G"""
        assert(G.number_of_nodes() >= 2)
        while True:
            n1, n2 = random.sample(G.nodes, 2)
            if n1 is not n2:
                return n1, n2